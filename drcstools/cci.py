# AUTOGENERATED! DO NOT EDIT! File to edit: 05_cci.ipynb (unless otherwise specified).

__all__ = ['stormdetection', 'stormdetection2']

# Cell
import xarray as xr
import numpy as np
from sklearn.cluster import KMeans

import matplotlib.pyplot as plt

# Cell
from .derivative import *
from .storm import *
from .helper_functions import *

def stormdetection(stormobj, slpname = "slp", pmax = 100000):

    lon = stormobj._get_name_longitude()
    lat = stormobj._get_name_latitude()

    stormobj.derivative(slpname, N = 20, dim = lon, order = 1)
    stormobj.derivative(slpname, N = 20, dim = lat, order = 1)

    stormobj.derivative(slpname, N = 20, dim = lon, order = 2)
    stormobj.derivative(slpname, N = 20, dim = lat, order = 2)

    stormobj.ds['area_t'] = ((lat, lon),
                            grid_cell_areas(lon1d = stormobj.ds[lon].values,
                                             lat1d = stormobj.ds[lat].values))

    zero_crossings_x = xr.where(xr.ufuncs.signbit(stormobj.ds["dd{}{}".format(lon, slpname)]).astype(int).diff("lon") != 0, 1, 0)
    zero_crossings_y = xr.where(xr.ufuncs.signbit(stormobj.ds["dd{}{}".format(lat, slpname)]).astype(int).diff("lat") != 0, 1, 0)
    zero_crossings = xr.where((zero_crossings_x == 1) & (zero_crossings_y == 1), 1, 0)

    dP = 0.5 * (stormobj.ds["dd{}{}".format(lon, slpname)] + stormobj.ds["dd{}{}".format(lat, slpname)])

    Pzonal = dP.mean([stormobj._get_name_time(), lat])

    lows = stormobj.ds[slpname].where(zero_crossings == 1).where(dP - Pzonal < 0)
    dP = dP.where(lows < pmax)
    lows = lows.where(lows < pmax)

    stormobj.ds["lows"] = lows
    stormobj.ds["dP"] = dP
    return stormobj


# def stormtracking(storm)

# Cell
def stormdetection2(x):
    n = 20
    tmp_clust = x.reshape(-1,1)
    k_means = KMeans(n_clusters=n, random_state= 0)
    k_means.fit(tmp_clust)
    X_clustered = k_means.labels_
    X_clustered = X_clustered.reshape(x.shape)


    label_list = [x[X_clustered == i].mean() for i in np.arange(0,n)]
    mean_sort = np.argsort(np.asarray(label_list))

    new = X_clustered.copy().astype(float)

    for step, i in enumerate(mean_sort):
        fac = step * 0.1
        new[X_clustered == i] = fac
    new = (new * 10).astype(int)

    return new
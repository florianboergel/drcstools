# AUTOGENERATED! DO NOT EDIT! File to edit: 03_helper_functions.ipynb (unless otherwise specified).

__all__ = ['rotated_grid_transform', 'transform_calendar', 'read_netcdfs', 'adjust_lon_lat', 'measure',
           'calculate_area_t']

# Cell
import xarray as xr
import numpy as np
from glob import glob

# Cell
def rotated_grid_transform(grid_in, option, SP_coor):
    """
    rotated pole
    """

    pi = np.pi
    lon = grid_in[0]
    lat = grid_in[1];

    lon = (lon*pi)/180; # Convert degrees to radians
    lat = (lat*pi)/180;

    SP_lon = SP_coor[0];
    SP_lat = SP_coor[1];

    SP_lon = SP_lon - 180
    SP_lat = -SP_lat

    theta = 90+SP_lat; # Rotation around y-axis
    phi = SP_lon; # Rotation around z-axis

    theta = (theta*pi)/180;
    phi = (phi*pi)/180; # Convert degrees to radians

    x = np.cos(lon)*np.cos(lat); # Convert from spherical to cartesian coordinates
    y = np.sin(lon)*np.cos(lat);
    z = np.sin(lat);

    if option == 1: # Regular -> Rotated

        x_new = np.cos(theta)*np.cos(phi)*x + np.cos(theta)*np.sin(phi)*y + np.sin(theta)*z;
        y_new = -np.sin(phi)*x + np.cos(phi)*y;
        z_new = -np.sin(theta)*np.cos(phi)*x - np.sin(theta)*np.sin(phi)*y + np.cos(theta)*z;

    else:  # Rotated -> Regular

        phi = -phi;
        theta = -theta;

        x_new = np.cos(theta)*np.cos(phi)*x + np.sin(phi)*y + np.sin(theta)*np.cos(phi)*z;
        y_new = -np.cos(theta)*np.sin(phi)*x + np.cos(phi)*y - np.sin(theta)*np.sin(phi)*z;
        z_new = -np.sin(theta)*x + np.cos(theta)*z;

    lon_new = np.arctan2(y_new,x_new); # Convert cartesian back to spherical coordinates
    lat_new = np.arcsin(z_new);

    lon_new = (lon_new*180)/pi; # Convert radians back to degrees
    lat_new = (lat_new*180)/pi;

    return lon_new , lat_new

# Cell
def transform_calendar(ds,
                       timedim="time",
                       calendarname="proleptic_gregorin"):
    """Transforms calendar of time index in xarray dataset"""
    ds[timedim].attrs['calendar'] = calendarname
    return ds

# Cell
def read_netcdfs(files, dim, transform_func, transform_calendar=None, cftime = True):
    """Reads multiples netcdfs files. Should be used when open_mfdatasets is to slow."""
    def process_one_path(path):
        if transform_calendar is not None:
            calendar = False
        else:
            calendar = True
        with xr.open_dataset(path, decode_times = calendar, use_cftime = cftime) as ds:
            if transform_calendar is not None:
                ds[dim].attrs['calendar'] = transform_calendar
                ds = xr.decode_cf(ds, use_cftime = cftime)
            if transform_func is not None:
                ds = transform_func(ds)
            ds.load()
            return ds
    paths = sorted(glob(files))
    datasets = [process_one_path(p) for p in paths]
    combined = xr.concat(datasets, dim)
    return combined

# Cell
def adjust_lon_lat(ds, lon_name, lat_name, reverse = False):
    """Adjusts longitude from 0 to 360 to -180 to 180 and reverses latitude."""

    if reverse == True:
        ds = ds.reindex({lat_name:ds[lat_name][::-1]})

    ds['_longitude_adjusted'] = xr.where(
        ds[lon_name] > 180,
        ds[lon_name] - 360,
        ds[lon_name])

    ds = (ds
          .swap_dims({lon_name: '_longitude_adjusted'})
          .sel(**{'_longitude_adjusted': sorted(ds._longitude_adjusted)})
          .drop(lon_name))

    ds = ds.rename({'_longitude_adjusted': lon_name})

    return ds

# Cell
def measure(lat1, lon1, lat2, lon2):
    """Calculates area of lon-lat grid cell in $m^2$"""
    R = 6378.137
    dLat = lat2 * np.pi / 180 - lat1 * np.pi / 180
    dLon = lon2 * np.pi / 180 - lon1 * np.pi / 180
    a = np.sin(dLat/2) * np.sin(dLat/2) + np.cos(lat1 * np.pi / 180) * np.cos(lat2 * np.pi / 180) * np.sin(dLon/2) * np.sin(dLon/2)
    c = 2 * np.arctan2(np.sqrt(a), np.sqrt(1-a))
    d = R * c
    return d * 1000

# Cell
def calculate_area_t(lon, lat):
    """Calculates area of lon-lat grid"""
    dlat = np.diff(lat)[0]
    dlon = np.diff(lon)[0]
    lats = lat - dlat/2
    lons = lon - dlon/2

    lats = np.append(lats, lats[-1] + dlat)
    lons = np.append(lons, lons[-1] + dlon)

    area_t = np.zeros((lat.size, lon.size))

    for j in range(1, len(lats)):
        for i in range(1, len(lons)):
            area_t[j-1, i-1] = measure(lats[j-1],lons[i-1],lats[j],lons[i])

    return area_t